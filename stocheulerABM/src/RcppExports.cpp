// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

// SIRMarkov_ABM
Rcpp::List SIRMarkov_ABM(const double dt, const double tmax, const int S, const int I, const int R, const double beta, const double gamma, const bool verbose);
RcppExport SEXP _stocheulerABM_SIRMarkov_ABM(SEXP dtSEXP, SEXP tmaxSEXP, SEXP SSEXP, SEXP ISEXP, SEXP RSEXP, SEXP betaSEXP, SEXP gammaSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const double >::type dt(dtSEXP);
    Rcpp::traits::input_parameter< const double >::type tmax(tmaxSEXP);
    Rcpp::traits::input_parameter< const int >::type S(SSEXP);
    Rcpp::traits::input_parameter< const int >::type I(ISEXP);
    Rcpp::traits::input_parameter< const int >::type R(RSEXP);
    Rcpp::traits::input_parameter< const double >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type gamma(gammaSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(SIRMarkov_ABM(dt, tmax, S, I, R, beta, gamma, verbose));
    return rcpp_result_gen;
END_RCPP
}
// SIRMarkov_MNRM
Rcpp::NumericMatrix SIRMarkov_MNRM(const double tmax, const int S, const int I, const int R, const double beta, const double gamma, const bool verbose);
RcppExport SEXP _stocheulerABM_SIRMarkov_MNRM(SEXP tmaxSEXP, SEXP SSEXP, SEXP ISEXP, SEXP RSEXP, SEXP betaSEXP, SEXP gammaSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const double >::type tmax(tmaxSEXP);
    Rcpp::traits::input_parameter< const int >::type S(SSEXP);
    Rcpp::traits::input_parameter< const int >::type I(ISEXP);
    Rcpp::traits::input_parameter< const int >::type R(RSEXP);
    Rcpp::traits::input_parameter< const double >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type gamma(gammaSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(SIRMarkov_MNRM(tmax, S, I, R, beta, gamma, verbose));
    return rcpp_result_gen;
END_RCPP
}
// SIRnonMarkov_ABM
Rcpp::List SIRnonMarkov_ABM(const double dt, const double tmax, const int S, const int I, const int R, const double beta, const double gamma_shape, const double gamma_scale, const bool verbose);
RcppExport SEXP _stocheulerABM_SIRnonMarkov_ABM(SEXP dtSEXP, SEXP tmaxSEXP, SEXP SSEXP, SEXP ISEXP, SEXP RSEXP, SEXP betaSEXP, SEXP gamma_shapeSEXP, SEXP gamma_scaleSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const double >::type dt(dtSEXP);
    Rcpp::traits::input_parameter< const double >::type tmax(tmaxSEXP);
    Rcpp::traits::input_parameter< const int >::type S(SSEXP);
    Rcpp::traits::input_parameter< const int >::type I(ISEXP);
    Rcpp::traits::input_parameter< const int >::type R(RSEXP);
    Rcpp::traits::input_parameter< const double >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type gamma_shape(gamma_shapeSEXP);
    Rcpp::traits::input_parameter< const double >::type gamma_scale(gamma_scaleSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(SIRnonMarkov_ABM(dt, tmax, S, I, R, beta, gamma_shape, gamma_scale, verbose));
    return rcpp_result_gen;
END_RCPP
}
// SIRnonMarkov_MNRM
Rcpp::NumericMatrix SIRnonMarkov_MNRM(const double tmax, const int S, const int I, const int R, const double beta, const double gamma_shape, const double gamma_scale, const bool verbose);
RcppExport SEXP _stocheulerABM_SIRnonMarkov_MNRM(SEXP tmaxSEXP, SEXP SSEXP, SEXP ISEXP, SEXP RSEXP, SEXP betaSEXP, SEXP gamma_shapeSEXP, SEXP gamma_scaleSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const double >::type tmax(tmaxSEXP);
    Rcpp::traits::input_parameter< const int >::type S(SSEXP);
    Rcpp::traits::input_parameter< const int >::type I(ISEXP);
    Rcpp::traits::input_parameter< const int >::type R(RSEXP);
    Rcpp::traits::input_parameter< const double >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type gamma_shape(gamma_shapeSEXP);
    Rcpp::traits::input_parameter< const double >::type gamma_scale(gamma_scaleSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(SIRnonMarkov_MNRM(tmax, S, I, R, beta, gamma_shape, gamma_scale, verbose));
    return rcpp_result_gen;
END_RCPP
}
// discretise
Rcpp::NumericMatrix discretise(const Rcpp::NumericMatrix& out, const double dt);
RcppExport SEXP _stocheulerABM_discretise(SEXP outSEXP, SEXP dtSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type out(outSEXP);
    Rcpp::traits::input_parameter< const double >::type dt(dtSEXP);
    rcpp_result_gen = Rcpp::wrap(discretise(out, dt));
    return rcpp_result_gen;
END_RCPP
}
// inhomPP_piecewiseconst
std::vector<double> inhomPP_piecewiseconst(const Rcpp::NumericVector& tvec, const Rcpp::NumericVector& lambdavec, const double tmax, const bool first);
RcppExport SEXP _stocheulerABM_inhomPP_piecewiseconst(SEXP tvecSEXP, SEXP lambdavecSEXP, SEXP tmaxSEXP, SEXP firstSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type tvec(tvecSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type lambdavec(lambdavecSEXP);
    Rcpp::traits::input_parameter< const double >::type tmax(tmaxSEXP);
    Rcpp::traits::input_parameter< const bool >::type first(firstSEXP);
    rcpp_result_gen = Rcpp::wrap(inhomPP_piecewiseconst(tvec, lambdavec, tmax, first));
    return rcpp_result_gen;
END_RCPP
}
// inhomPP_piecewiseconst_reject
Rcpp::NumericVector inhomPP_piecewiseconst_reject(const Rcpp::NumericVector& tvec, const Rcpp::NumericVector& lambdavec);
RcppExport SEXP _stocheulerABM_inhomPP_piecewiseconst_reject(SEXP tvecSEXP, SEXP lambdavecSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type tvec(tvecSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type lambdavec(lambdavecSEXP);
    rcpp_result_gen = Rcpp::wrap(inhomPP_piecewiseconst_reject(tvec, lambdavec));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_stocheulerABM_SIRMarkov_ABM", (DL_FUNC) &_stocheulerABM_SIRMarkov_ABM, 8},
    {"_stocheulerABM_SIRMarkov_MNRM", (DL_FUNC) &_stocheulerABM_SIRMarkov_MNRM, 7},
    {"_stocheulerABM_SIRnonMarkov_ABM", (DL_FUNC) &_stocheulerABM_SIRnonMarkov_ABM, 9},
    {"_stocheulerABM_SIRnonMarkov_MNRM", (DL_FUNC) &_stocheulerABM_SIRnonMarkov_MNRM, 8},
    {"_stocheulerABM_discretise", (DL_FUNC) &_stocheulerABM_discretise, 2},
    {"_stocheulerABM_inhomPP_piecewiseconst", (DL_FUNC) &_stocheulerABM_inhomPP_piecewiseconst, 4},
    {"_stocheulerABM_inhomPP_piecewiseconst_reject", (DL_FUNC) &_stocheulerABM_inhomPP_piecewiseconst_reject, 2},
    {NULL, NULL, 0}
};

RcppExport void R_init_stocheulerABM(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
