# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Simulate Markovian SIR Model via Agent-based Model (ABM)
#'
#' Sample a trajectory from the Markovian SIR model using the approximate ABM.
#'
#' @param dt the time step
#' @param tmax maximum time of simulation
#' @param S initial number of susceptible individuals
#' @param I initial number of infected & infectious individuals
#' @param R initial number of recovered individuals
#' @param beta the product of transmission probability and contact rate
#' @param gamma inverse of the duration of infectiousness
#' @param verbose print extra information?
#'
#' @return a list (use \code{do.call(cbind,out)} to convert to \code{matrix})
#'
#'
#' @export
SIRMarkov_ABM <- function(dt, tmax, S, I, R, beta, gamma, verbose) {
    .Call('_stocheulerABM_SIRMarkov_ABM', PACKAGE = 'stocheulerABM', dt, tmax, S, I, R, beta, gamma, verbose)
}

#' Simulate Markovian SIR Model via Modified Next Reaction Method (MNRM)
#'
#' Sample a trajectory from the Markovian SIR model using the MNRM algorithm presented in:
#'   * Anderson, D. F. (2007). A modified next reaction method for simulating chemical systems with time dependent propensities and delays. Journal of Chemical Physics, 127(21). \url{https://doi.org/10.1063/1.2799998}
#'
#' @param tmax maximum time of simulation
#' @param S initial number of susceptible individuals
#' @param I initial number of infected & infectious individuals
#' @param R initial number of recovered individuals
#' @param beta the product of transmission probability and contact rate
#' @param gamma inverse of the duration of infectiousness
#' @param verbose print extra information?
#'
#' @return a matrix
#'
#'
#' @export
SIRMarkov_MNRM <- function(tmax, S, I, R, beta, gamma, verbose) {
    .Call('_stocheulerABM_SIRMarkov_MNRM', PACKAGE = 'stocheulerABM', tmax, S, I, R, beta, gamma, verbose)
}

#' Simulate non-Markovian SIR Model via Agent-based Model (ABM)
#'
#' In this non-Markovian variant of the SIR model, the infectious period has a Weibull distribution. Sample a trajectory
#' from it using the approximate ABM.
#'
#' @param dt the time step
#' @param tmax maximum time of simulation
#' @param S initial number of susceptible individuals
#' @param I initial number of infected & infectious individuals
#' @param R initial number of recovered individuals
#' @param beta the product of transmission probability and contact rate
#' @param gamma_shape shape parameter of Weibull distributed infectious period
#' @param gamma_scale scale parameter of Weibull distributed infectious period
#' @param verbose print extra information?
#'
#' @return a list (use \code{do.call(cbind,out)} to convert to \code{matrix})
#'
#'
#' @export
SIRnonMarkov_ABM <- function(dt, tmax, S, I, R, beta, gamma_shape, gamma_scale, verbose) {
    .Call('_stocheulerABM_SIRnonMarkov_ABM', PACKAGE = 'stocheulerABM', dt, tmax, S, I, R, beta, gamma_shape, gamma_scale, verbose)
}

#' Simulate non-Markovian SIR Model via Modified Next Reaction Method (MNRM)
#'
#' In this non-Markovian variant of the SIR model, the infectious period has a Weibull distribution.
#'
#' Sample a trajectory from the Markovian SIR model using the MNRM algorithm presented in:
#'   * Anderson, D. F. (2007). A modified next reaction method for simulating chemical systems with time dependent propensities and delays. Journal of Chemical Physics, 127(21). \url{https://doi.org/10.1063/1.2799998}
#'
#' @param tmax maximum time of simulation
#' @param S initial number of susceptible individuals
#' @param I initial number of infected & infectious individuals
#' @param R initial number of recovered individuals
#' @param beta the product of transmission probability and contact rate
#' @param gamma_shape shape parameter of Weibull distributed infectious period
#' @param gamma_scale scale parameter of Weibull distributed infectious period
#' @param verbose print extra information?
#'
#' @return a matrix
#'
#'
#' @export
SIRnonMarkov_MNRM <- function(tmax, S, I, R, beta, gamma_shape, gamma_scale, verbose) {
    .Call('_stocheulerABM_SIRnonMarkov_MNRM', PACKAGE = 'stocheulerABM', tmax, S, I, R, beta, gamma_shape, gamma_scale, verbose)
}

#' Discretize Output
#'
#' Modified from \code{smfsb} package
#'
#' @param out a matrix
#' @param out dt the discretization lattice
#'
#' @export
discretise <- function(out, dt) {
    .Call('_stocheulerABM_discretise', PACKAGE = 'stocheulerABM', out, dt)
}

#' Sample an Inhomogeneous Poisson Process with Piecewise Constant Intensity
#'
#' Sample an inhomogeneous Poisson process withe piecewise constant intensity using an algorithm presented in:
#'   * Leemis, Lawrence M., and Stephen Keith Park. Discrete-event simulation: A first course. Upper Saddle River, NJ: Pearson Prentice Hall, 2006.
#'
#' @param tvec times at which the intensity changes (in j=0,1,...,k)
#' @param lambdavec values at the left endpoints of intensity (in j=0,1,...,k)
#' @param tmax maximum simulation time (usually equal to value of \code{tvec} at k)
#' @param first if \code{TRUE}, stop early and return the first event in the process
#'
#' @return a vector of event times in the counting process
#'
#'
#' @export
inhomPP_piecewiseconst <- function(tvec, lambdavec, tmax, first) {
    .Call('_stocheulerABM_inhomPP_piecewiseconst', PACKAGE = 'stocheulerABM', tvec, lambdavec, tmax, first)
}

#' Sample First Event Time Inhomogeneous Poisson Process with Piecewise Constant Intensity
#'
#' Sample an inhomogeneous Poisson process withe piecewise constant intensity using an accept-reject algorithm.
#' If the first event occurs after the time that the intensity is defined via \code{lambdavec}, return a \code{NaN}
#'
#' @param tvec times at which the intensity changes (in j=0,1,...,k)
#' @param lambdavec values at the left endpoints of intensity (in j=0,1,...,k)
#'
#' @return a vector of number of rejections and the time of first event
#'
#'
#' @export
inhomPP_piecewiseconst_reject <- function(tvec, lambdavec) {
    .Call('_stocheulerABM_inhomPP_piecewiseconst_reject', PACKAGE = 'stocheulerABM', tvec, lambdavec)
}

